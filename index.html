<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Gateway</title>
<style>
body{
    margin:0;
    height:100vh;
    display:flex;
    align-items:center;
    justify-content:center;
    background:#f2f4f8;
    font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto;
}
.box{
    background:#fff;
    padding:36px 32px;
    border-radius:14px;
    box-shadow:0 10px 30px rgba(0,0,0,.15);
    text-align:center;
    max-width:520px;
    width:90%;
}
h1{
    margin:0 0 16px;
    font-size:26px;
}
p{
    margin:0;
    color:#555;
    font-size:15px;
}
</style>
</head>
<body>

<div class="box">
    <h1 id="title">ðŸ”„ æ–‡ä»¶è®¿é—®ç½‘å…³</h1>
    <p id="status">æ­£åœ¨æ£€æµ‹ç½‘ç»œçŽ¯å¢ƒâ€¦</p>
</div>

<script>
/* ================== é…ç½® ================== */

/* IPv6 æŽ¢æµ‹ç«™ç‚¹ï¼ˆå¿…é¡»æ˜¯ AAAAï¼‰ */
const IPV6_CHECK_SITE = 'https://openlist.å¸acg.xyz';

/* IPv6 å¯ç”¨ â†’ ç›´è¿žç«žé€Ÿ */
const DIRECT_SITES = [
    'https://openlist.å¸acg.xyz',
    'https://openlist-standby.å¸acg.xyz'
];

/* IPv6 ä¸å¯ç”¨ â†’ ä»£ç†ç«žé€Ÿ */
const PROXY_SITES = [
    'https://1-openlist.å¸acg.xyz',
    'https://2-openlist.å¸acg.xyz',
    'https://3-openlist.å¸acg.xyz',
    'https://1-openlist-standby.å¸acg.xyz',
    'https://2-openlist-standby.å¸acg.xyz',
    'https://3-openlist-standby.å¸acg.xyz'
];

/* ========================================= */

const LANG = (() => {
    const l = (navigator.language || '').toLowerCase();
    if (l.startsWith('zh-tw') || l.startsWith('zh-hk')) return 'tw';
    if (l.startsWith('zh')) return 'cn';
    return 'en';
})();

const TEXT = {
    cn:{
        title:'ðŸ”„ æ–‡ä»¶è®¿é—®ç½‘å…³',
        checking:'æ­£åœ¨æ£€æµ‹ IPv6 ç½‘ç»œâ€¦',
        v6:'IPv6 å¯ç”¨ï¼Œæµ‹é€Ÿç›´è¿žèŠ‚ç‚¹â€¦',
        v4:'IPv6 ä¸å¯ç”¨ï¼Œæµ‹é€Ÿä»£ç†èŠ‚ç‚¹â€¦',
        go:'å·²é€‰æ‹©æœ€å¿«èŠ‚ç‚¹ï¼Œæ­£åœ¨è·³è½¬â€¦'
    },
    tw:{
        title:'ðŸ”„ æª”æ¡ˆå­˜å–é–˜é“',
        checking:'æ­£åœ¨æª¢æ¸¬ IPv6 ç¶²è·¯â€¦',
        v6:'IPv6 å¯ç”¨ï¼Œæ¸¬é€Ÿç›´é€£ç¯€é»žâ€¦',
        v4:'IPv6 ä¸å¯ç”¨ï¼Œæ¸¬é€Ÿä»£ç†ç¯€é»žâ€¦',
        go:'å·²é¸æ“‡æœ€å¿«ç¯€é»žï¼Œæ­£åœ¨è·³è½‰â€¦'
    },
    en:{
        title:'ðŸ”„ File Gateway',
        checking:'Checking IPv6 connectivityâ€¦',
        v6:'IPv6 available, testing direct nodesâ€¦',
        v4:'IPv6 unavailable, testing proxy nodesâ€¦',
        go:'Fastest node selected, redirectingâ€¦'
    }
};

document.getElementById('title').textContent = TEXT[LANG].title;
document.getElementById('status').textContent = TEXT[LANG].checking;

const statusEl = document.getElementById('status');

const path =
    location.pathname +
    location.search +
    location.hash;

/* IPv6 æ£€æµ‹ */
function checkIPv6() {
    return new Promise(resolve => {
        const img = new Image();
        let done = false;

        img.onload = () => !done && (done = true, resolve(true));
        img.onerror = () => !done && (done = true, resolve(false));

        img.src = IPV6_CHECK_SITE + '/favicon.ico?_=' + Date.now();

        setTimeout(() => {
            if (!done) {
                done = true;
                resolve(false);
            }
        }, 2000);
    });
}

/* èŠ‚ç‚¹ç«žé€Ÿï¼šè°å…ˆæˆåŠŸè°èµ¢ */
function raceSites(sites, timeout = 2500) {
    return new Promise(resolve => {
        let finished = false;

        const timer = setTimeout(() => {
            if (!finished) {
                finished = true;
                resolve(sites[0]); // å…œåº•
            }
        }, timeout);

        sites.forEach(site => {
            const img = new Image();
            img.onload = () => {
                if (!finished) {
                    finished = true;
                    clearTimeout(timer);
                    resolve(site);
                }
            };
            img.onerror = () => {};
            img.src = site + '/favicon.ico?_=' + Math.random();
        });
    });
}

(async () => {
    const hasV6 = await checkIPv6();

    let sites;
    if (hasV6) {
        statusEl.textContent = TEXT[LANG].v6;
        sites = DIRECT_SITES;
    } else {
        statusEl.textContent = TEXT[LANG].v4;
        sites = PROXY_SITES;
    }

    const fastest = await raceSites(sites);

    statusEl.textContent = TEXT[LANG].go;

    setTimeout(() => {
        location.replace(fastest + path);
    }, 300);
})();
</script>

</body>
</html>
